[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Chris Hilsinger-Pate",
    "section": "",
    "text": "I am a Business Analyst at Albertsons Companies, where I specialize in supply chain optimization and continuous improvement. In my role, I utilize R, Python, and SQL to develop tools and reports that enhance productivity, support informed decision-making, and drive key strategic initiatives.\n\nSkills\n\nSQL\nPython\nR\n\nPower BI\nFlask\nHTML/CSS\n\n\n\n\n\n\n\nGallery\n\n\n\n\nTop Ten Fantasy Football TE Table\n\n\n\n\n\nGraphify\n\n\n\n\n\nAudience Score and Tomatometer of Top Ten English Netflix Films\n\n\n\n\n\nTikTok Stars Across Platforms"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "posts/postwithploit/index.html",
    "href": "posts/postwithploit/index.html",
    "title": "Test Post",
    "section": "",
    "text": "This is a post with executable code.\n\n\nCode\n1 + 1\n\n\n2"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Graphify: Identifying Core Spotify Artists with Network Analysis\n\n\n\n\n\n\nPython\n\n\nNetwork Analysis\n\n\nData Visualization\n\n\n\n\n\n\n\n\n\nJul 5, 2024\n\n\nChris Hilsinger-Pate\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html#gallery",
    "href": "index.html#gallery",
    "title": "Chris Hilsinger-Pate",
    "section": "Gallery",
    "text": "Gallery\n\n\n\nFantasy Football Table\n\n\n\n\n\nGraphify\n\n\n\n\n\nNetflix Films\n\n\n\n\n\nTikTok Stars Across Platforms"
  },
  {
    "objectID": "posts/graphify/index.html",
    "href": "posts/graphify/index.html",
    "title": "Graphify: Identifying Core Spotify Artists with Network Analysis",
    "section": "",
    "text": "Uncover insights into individual music preferences through the lens of network analysis."
  },
  {
    "objectID": "posts/graphify/index.html#introduction",
    "href": "posts/graphify/index.html#introduction",
    "title": "Graphify: Identifying Core Spotify Artists with Network Analysis",
    "section": "Introduction",
    "text": "Introduction\nAs the boundaries between music genres have become increasingly blurred, discussions about music preferences often devolve into people rattling off lists of artists they listen to, without giving much thought to how those artists fit into the broader context of their personal playlists. In an effort to make more sense of my own music taste, I turned to network analysis.\nNetworks are structures consisting of entities (nodes) and their relationships (edges), and network analysis provides the methods to analyze the core features and patterns of networks (Hevey, 2018). A network people are likely familiar with is their social media network. In a social media network such as LinkedIn, individuals are nodes and their “Connections” are edges, indicating a relationship of some sort between people.\nFor this project, each of my top 30 most listened to Spotify artists will be represented as nodes. The edges between nodes will be determined by each artist’s related artists as defined by Spotify’s “Fans Also Like” feature. Spotify selects an artist’s related artists based on the listening habits of their fans (“Fans also like”, n.d.). For example, an edge exists between Noah Kahan and Zach Bryan because they appear on each other’s “Fans Also Like” lists (as of June 15, 2024).\nIn order to access one’s own Spotify data via the Spotify Web API, a Spotify Developer account is required. Spotify users can sign up for a Developer account here."
  },
  {
    "objectID": "posts/graphify/index.html#references",
    "href": "posts/graphify/index.html#references",
    "title": "Graphify: Identifying Core Spotify Artists with Network Analysis",
    "section": "References",
    "text": "References\nFans also like. Spotify. (n.d.). https://support.spotify.com/us/artists/article/fans-also-like/   Hevey, D. (2018). Network analysis: a brief overview and tutorial. Health Psychology and Behavioral Medicine, 6(1), 301–328. https://doi.org/10.1080/21642850.2018.1521283   Scott, J. (2000). Social Network Analysis: A Handbook (Second Edition). Sage Publications."
  },
  {
    "objectID": "posts/graphify/index.html#creating-a-python-class-for-data-storage",
    "href": "posts/graphify/index.html#creating-a-python-class-for-data-storage",
    "title": "Graphify: Identifying Core Spotify Artists with Network Analysis",
    "section": "Creating a Python Class for Data Storage",
    "text": "Creating a Python Class for Data Storage\n\n\nCode\nclass Artist:\n    \"\"\"\n    Data class to store a Spotify artist's attributes.\n\n    Attributes:\n        name (str): The name of the artist.\n        id (str): The artist's Spotify unique identifier.\n        image_url (str): URL to the artist's Spotify image.\n        spotify_popularity (int): Popularity score of the artist on Spotify (0 to 100).\n        user_rank (int): Rank of the artist among the user's most listened to artists.\n        related_artists (list): List of the artist's \"Fans also like\" artists (includes \n                                artists not featured on mobile \"Fans also like\").\n\n    \"\"\"\n\n    def __init__(self, name, id, image_url, spotify_popularity, user_rank, related_artists=None):\n        \"\"\"\n        Initializes an Artist instance with the given attributes. \n\n        Args:\n            name (str): The name of the artist.\n            id (str): The artist's Spotify unique identifier.\n            image_url (str): URL to the artist's Spotify image.\n            spotify_popularity (int): Popularity score of the artist on Spotify (0 to 100).\n            user_rank (int): Rank of the artist among the user's most listened to artists.\n            related_artists (list, optional): List of the artist's \"Fans also like\" artists. \n                                              Defaults to an empty list if not provided.\n        \"\"\"\n        self.name = name \n        self.id = id \n        self.image_url = image_url \n        self.spotify_popularity = spotify_popularity \n        self.user_rank = user_rank\n        if related_artists is None:\n            related_artists = []\n        self.related_artists = related_artists"
  },
  {
    "objectID": "posts/graphify/index.html#define-functions",
    "href": "posts/graphify/index.html#define-functions",
    "title": "Graphify: Identifying Core Spotify Artists with Network Analysis",
    "section": "Define Functions",
    "text": "Define Functions\nFor this project, I need to make two distinct calls to the Spotify Web API. After the data is returned, it is processed and used to set the Artist class’ attributes. Both the method associated with the Artist class and function defined below utilize a function from the Spotipy library to make API calls and then parse the data.\n\n\nCode\n# data_functions.py\nimport spotipy\nfrom data_classes import Artist\n\ndef collect_top_artists(key, time_period, n_artists):\n    \"\"\"\n    Collects the user's top Spotify artists.\n\n    Retrieves the user's top artists over a given time period from the Spotify Web API. \n    It returns a list of 'Artist' instances.\n\n    Args:\n        key (spotipy.Spotify): Authenticated Spotify API client.\n        time_period (str): The time range over which to retrieve top artists. \n                           Valid values are 'short_term' (1 month), 'medium_term' \n                           (6 months), and 'long_term' (all-time).\n        n_artists (int): The number of top artists to retrieve.\n                           \n    Returns:\n        A list of 'Artist' objects representing the user's top artists.\n        \n    Raises:\n        spotipy.SpotifyException: If there is an error in the Spotify API request.\n    \"\"\"\n    sp = key \n    top_artists = sp.current_user_top_artists(time_range=time_period, limit=n_artists)\n    top_thirty_artists = []\n    for i in range(n_artists):\n        top_thirty_artists.append(Artist(top_artists['items'][i]['name'], \n                                      top_artists['items'][i]['id'], \n                                      top_artists['items'][i]['images'][0]['url'], \n                                      top_artists['items'][i]['popularity'], i + 1))\n    return top_thirty_artists"
  },
  {
    "objectID": "posts/graphify/index.html#import-python-libraries-and-environment-variables",
    "href": "posts/graphify/index.html#import-python-libraries-and-environment-variables",
    "title": "Graphify: Identifying Core Spotify Artists with Network Analysis",
    "section": "Import Python Libraries and Environment Variables",
    "text": "Import Python Libraries and Environment Variables\nexplain what you’re doing with the imports, environment variables, and prepping for authentication; make sure to include a link to the Spotify page where people can sign up for a developer account\n\n\nCode\n# main.py\nimport spotipy \nfrom spotipy.oauth2 import SpotifyOAuth\nfrom data_classes import Artist\nfrom data_functions import collect_top_artists, collect_related_artists\nimport dotenv\nimport os \nimport networkx as nx\nimport matplotlib.pyplot as plt\nfrom pyvis.network import Network\n\n# Load environment variables\ndotenv.load_dotenv()\n \nCLIENT_ID = os.getenv(\"SPOTIFY_CLIENT_ID\")\nCLIENT_SECRET = os.getenv(\"SPOTIFY_CLIENT_SECRET\")\nREDIRECT_URL = os.getenv(\"SPOTIFY_REDIRECT_URI\")\nSCOPE = os.getenv(\"SPOTIFY_SCOPE\")\n\n# Authenticate your Spotify account -- this will be your key\nsp = spotipy.Spotify(auth_manager=SpotifyOAuth(client_id=CLIENT_ID, \n                                               client_secret=CLIENT_SECRET,\n                                               redirect_uri=REDIRECT_URL,\n                                               scope=SCOPE))\n\n# Define how many artists to query and over which length of time \nN_ARTISTS = 30\nTIME_PERIOD = \"medium_term\""
  },
  {
    "objectID": "posts/graphify/index.html#code-execution",
    "href": "posts/graphify/index.html#code-execution",
    "title": "Graphify: Identifying Core Spotify Artists with Network Analysis",
    "section": "Code Execution",
    "text": "Code Execution\nI am creating my network with NetworkX and visualizing it with PyViz. To enhance the network visualization, I’m using each artist’s Spotify image to depict their node.\nOne thing worth noting is that Spotify’s “Fans Also Like” is not always recriprocal. For example, Kacey Musgraves appears on Noah Kahan’s “Fans Also Like” but he does not appear on hers. A directed graph would most commonly be used to represent this type of relationship. However, I am using an undirected graph because the presence of an artist under another artist’s “Fans Also Like” – even if it is not recripocated – is reflective of a shared subset of fans. Artists who share a reciprocal connection will be connected by a bolder line, which represents an edge with greater weight.\n\n\nCode\n# main.py\n# Store artist data in a list (note that data is stored in Artist class)\ntop_thirty_artists = collect_top_artists(sp, TIME_PERIOD, N_ARTISTS)\n\n# Collect list of artists in each artist's \"Fans also like\"\nfor artist in top_thirty_artists:\n    artist.collect_related_artists(sp)\n\n# Initialize your network of artists\nN = nx.Graph()\n\n# Create a node for each of the top artists\nfor artist in top_thirty_artists:\n    N.add_node(artist.name, size=30, shape='circularImage', image=artist.image_url)\n\n# Check if each top artist is in the other top artists' \"Fans also like\" \n# If edge already exists, adjust the weight; create edge if one does not exist \nfor artist in top_thirty_artists:\n    for different_artist in top_thirty_artists:\n        if artist != different_artist:\n            if artist.name in different_artist.related_artists:\n                if N.has_edge(artist.name, different_artist.name):\n                    N[artist.name][different_artist.name]['weight'] += 1\n                else:\n                    N.add_edge(artist.name, different_artist.name, weight=1, color=\"black\")\n\n# Store the betweenness centrality of each artist in a dictionary\ncentrality_values = nx.betweenness_centrality(N)\n\n# Store the degree centrality of each artist in a dictionary\ndegree_values = nx.degree_centrality(N)\n\nnet_test = Network(notebook=True, directed=False, height='95vh', width='100%')\nnet_test.from_nx(N)\nnew_test_path = 'graph.html'\nnet_test.show(new_test_path)"
  },
  {
    "objectID": "posts/graphify/index.html#results",
    "href": "posts/graphify/index.html#results",
    "title": "Graphify: Identifying Core Spotify Artists with Network Analysis",
    "section": "Results",
    "text": "Results\nZoom within the frame for a better view of the artists. Click and drag nodes to move artists. \n\n\n\n\n\n\nNote\n\n\n\nI am using cluster in accordance with John Scott’s definition: “An area of relatively high density in a graph” (2000, p. 127).\n\n\nAt first glance, the graph reveals two distinct clusters. In addition to those two clusters, there are five artists without any connections; they are completely isolated from the rest of the network.\nOne metric we can use to describe the graph is inclusiveness, “…the number of points that are included within the various connected parts of the graph” (Scott, 2000, p. 70). Considering five of my top 30 artists are without any connections, the inclusiveness of my network (expressed as a proportion) is 0.83. A perfectly inclusive network would have an inclusiveness score of 1. Without other Spotify networks to compare to, it is impossible for me to say if my network of top artists is highly or minimally inclusive.\nTo better understand which artists are most important in my network, I turned to centrality measures. The two centrality measures I’m interested in for this project are betweenness centrality and degree centrality.\nBetweenness centrality measures “…the extent to which a particular point lies ‘between’ the various other points in the graph” (Scott, 2000, 87). One can think of betweenness centrality as a measure of how important a node is as a “bridge” between other nodes. The artists with the two highest betweenness centrality scores in my network are The Weeknd and Noah Kahan. The Weeknd’s role as a bridge is especially apparent as he is the sole connector between my “pop” artists and “hip hop/R&B” artists.\nDegree centrality is effectively a popularity score as it measures how many nodes a node is connected to. The Weeknd, Gregory Alan Isakov, and Billie Eilish tied for the highest degree centrality with a 0.28.\nNetwork analysis reveals that my music taste is not one-dimensional and is most strongly characterized by two distinct clusters of artists. The Weeknd’s role as both a connector and highly popular figure in my network of artists underscores his significance in my music preferences."
  },
  {
    "objectID": "posts/graphify/index.html#future-applications",
    "href": "posts/graphify/index.html#future-applications",
    "title": "Graphify: Identifying Core Spotify Artists with Network Analysis",
    "section": "Future Applications",
    "text": "Future Applications\nWhile this project utilized network analysis for its descriptive power, network analysis can also be used for predictive purposes. One such use case would be a recommendation system to recommend new artists whose music a person is likely to enjoy. Beyond music preferences and listening habits, network analysis offers valuable applications in a number of business contexts. For example, network analysis may be immensely valuable in a merger and acquisition, where seamless integration is of the utmost importance. Network analysis could reveal structural holes and knowledge gaps that would have the potential to lead to a loss of tribal knowledge and disrupt integration processes."
  },
  {
    "objectID": "posts/graphify/index.html#creating-a-class-for-data-storage",
    "href": "posts/graphify/index.html#creating-a-class-for-data-storage",
    "title": "Graphify: Identifying Core Spotify Artists with Network Analysis",
    "section": "Creating a Class for Data Storage",
    "text": "Creating a Class for Data Storage\nThe Artist class is designed to store data collected from the Spotify Web API. Each instance of the Artist class represents one of my top Spotify artists. While I’m not using the spotify_popularity and user_rank attributes in this particular project, they could be used to add unique visual components to the networth graph I am creating. The collect_related_artists method retrieves each artist’s related artists.\n\n\nCode\n# data_classes.py\nclass Artist:\n    \"\"\"\n    Data class to store a Spotify artist's attributes.\n\n    Attributes:\n        name (str): The name of the artist.\n        id (str): The artist's Spotify unique identifier.\n        image_url (str): URL to the artist's Spotify image.\n        spotify_popularity (int): Popularity score of the artist on Spotify (0 to 100).\n        user_rank (int): Rank of the artist among the user's most listened to artists.\n        related_artists (list): List of the artist's \"Fans also like\" artists (includes \n                                artists not featured on mobile \"Fans also like\").\n\n    \"\"\"\n\n    def __init__(self, name, id, image_url, spotify_popularity, user_rank, related_artists=None):\n        \"\"\"\n        Initializes an Artist instance with the given attributes. \n\n        Args:\n            name (str): The name of the artist.\n            id (str): The artist's Spotify unique identifier.\n            image_url (str): URL to the artist's Spotify image.\n            spotify_popularity (int): Popularity score of the artist on Spotify (0 to 100).\n            user_rank (int): Rank of the artist among the user's most listened to artists.\n            related_artists (list, optional): List of the artist's \"Fans also like\" artists. \n                                              Defaults to an empty list if not provided.\n        \"\"\"\n        self.name = name \n        self.id = id \n        self.image_url = image_url \n        self.spotify_popularity = spotify_popularity \n        self.user_rank = user_rank\n        if related_artists is None:\n            related_artists = []\n        self.related_artists = related_artists\n\n    def collect_related_artists(self, key):\n        \"\"\"\n        Collects Spotify's \"Fans also like\" artists for each of the user's top artists.\n\n        This function updates each 'Artist' object with a list of the artist's related \n        artists using the Spotify Web API. \n\n        Args:\n            key (spotipy.Spotify): Authenticated Spotify API client.\n            top_ten_artists (list of Artist): A list of 'Artist' objects to query.\n        \n        Raises: \n            spotipy.SpotifyException: If there is an error in the Spotify API request.\n        \"\"\"\n        sp = key \n        related_artists = sp.artist_related_artists(self.id)\n        self.related_artists = [musician['name'] for musician in related_artists['artists']]"
  },
  {
    "objectID": "posts/graphify/index.html#import-libraries-modules-and-environment-variables",
    "href": "posts/graphify/index.html#import-libraries-modules-and-environment-variables",
    "title": "Graphify: Identifying Core Spotify Artists with Network Analysis",
    "section": "Import Libraries, Modules, and Environment Variables",
    "text": "Import Libraries, Modules, and Environment Variables\nBefore I can collect data and visualize my network of Spotify artists, I need to obtain a Spotify authentication token. This can be done with a number of parameters available through the Spotify Developer portal.\nI also define two variables – N_ARTISTS and TIME_PERIOD – in the following code chunk. Knowing my tendency to listen to a few artists in a high concentration, I opted to query only my top 30 artists. Querying more artists may lead to a more interesting graph but poses the risk of diluting the focus of the analysis. Including artists I hardly listen to in my analysis will provide little insight into my music taste. As for the time period I’ll be querying, I opted to go with my data from the last six months (medium term).\n\n\nCode\n# main.py\nimport spotipy \nfrom spotipy.oauth2 import SpotifyOAuth\nfrom data_classes import Artist\nfrom data_functions import collect_top_artists, collect_related_artists\nimport dotenv\nimport os \nimport networkx as nx\nimport matplotlib.pyplot as plt\nfrom pyvis.network import Network\n\n# Load environment variables\ndotenv.load_dotenv()\n \nCLIENT_ID = os.getenv(\"SPOTIFY_CLIENT_ID\")\nCLIENT_SECRET = os.getenv(\"SPOTIFY_CLIENT_SECRET\")\nREDIRECT_URI = os.getenv(\"SPOTIFY_REDIRECT_URI\")\nSCOPE = os.getenv(\"SPOTIFY_SCOPE\")\n\n# Authenticate your Spotify account -- this will be your key\nsp = spotipy.Spotify(auth_manager=SpotifyOAuth(client_id=CLIENT_ID, \n                                               client_secret=CLIENT_SECRET,\n                                               redirect_uri=REDIRECT_URI,\n                                               scope=SCOPE))\n\n# Define how many artists to query and over which length of time \nN_ARTISTS = 30\nTIME_PERIOD = \"medium_term\""
  }
]
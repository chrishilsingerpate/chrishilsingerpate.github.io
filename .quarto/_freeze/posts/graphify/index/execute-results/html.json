{
  "hash": "4c10e5e1789dde1966515aedcc35cb5f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Graphify: Identifying Core Spotify Artists with Network Analysis\"\nauthor: \"Chris Hilsinger-Pate\"\ndate: \"2024-07-05\"\ncategories: [Python, Network Analysis, Data Visualization]\nimage: \"Screenshot 2024-05-27 at 9.58.13â€¯PM.png\"\n---\n\n_Uncover insights into individual music preferences through the lens of network analysis._\n\n## Introduction\nAs the boundaries between music genres have become increasingly blurred, discussions about music preferences often devolve\ninto people rattling off lists of artists they listen to, without giving much thought to how those artists fit into the \nbroader context of their personal playlists. In an effort to make more sense of my own music taste, I turned to network analysis. \n\nNetworks are structures consisting of entities (nodes) and their relationships (edges), and network analysis provides the methods to \nanalyze the core features and patterns of networks (Hevey, 2018). A network people are likely familiar with is their social media network.\nIn a social media network such as LinkedIn, individuals are nodes and their \"Connections\" are edges, indicating a relationship of some sort \nbetween people. \n\nFor this project, each of my top 30 most listened to Spotify artists will be represented as nodes. The edges between nodes will be determined\nby each artist's related artists as defined by Spotify's \"Fans Also Like\" feature. Spotify selects an artist's related\nartists based on the listening habits of their fans (\"Fans also like\", n.d.). For example, an edge exists between Noah Kahan\nand Zach Bryan because they appear on each other's \"Fans Also Like\" lists (as of June 15, 2024).\n\nIn order to access one's own Spotify data via the Spotify Web API, a Spotify Developer account is required. Spotify users can sign up for a Developer \naccount <a href=\"https://developer.spotify.com/documentation/web-api/tutorials/getting-started\">here</a>. \n\n## Creating a Class for Data Storage \nThe `Artist` class is designed to store data collected from the Spotify Web API. Each instance of the `Artist` class represents one of my top Spotify artists. While I'm not using the `spotify_popularity` and `user_rank` attributes in this particular project, they could be used to add unique visual components to \nthe networth graph I am creating. The `collect_related_artists` method retrieves each artist's related artists. \n\n::: {#8bc39bef .cell execution_count=1}\n``` {.python .cell-code}\n# data_classes.py\nclass Artist:\n    \"\"\"\n    Data class to store a Spotify artist's attributes.\n\n    Attributes:\n        name (str): The name of the artist.\n        id (str): The artist's Spotify unique identifier.\n        image_url (str): URL to the artist's Spotify image.\n        spotify_popularity (int): Popularity score of the artist on Spotify (0 to 100).\n        user_rank (int): Rank of the artist among the user's most listened to artists.\n        related_artists (list): List of the artist's \"Fans also like\" artists (includes \n                                artists not featured on mobile \"Fans also like\").\n\n    \"\"\"\n\n    def __init__(self, name, id, image_url, spotify_popularity, user_rank, related_artists=None):\n        \"\"\"\n        Initializes an Artist instance with the given attributes. \n\n        Args:\n            name (str): The name of the artist.\n            id (str): The artist's Spotify unique identifier.\n            image_url (str): URL to the artist's Spotify image.\n            spotify_popularity (int): Popularity score of the artist on Spotify (0 to 100).\n            user_rank (int): Rank of the artist among the user's most listened to artists.\n            related_artists (list, optional): List of the artist's \"Fans also like\" artists. \n                                              Defaults to an empty list if not provided.\n        \"\"\"\n        self.name = name \n        self.id = id \n        self.image_url = image_url \n        self.spotify_popularity = spotify_popularity \n        self.user_rank = user_rank\n        if related_artists is None:\n            related_artists = []\n        self.related_artists = related_artists\n\n    def collect_related_artists(self, key):\n        \"\"\"\n        Collects Spotify's \"Fans also like\" artists for each of the user's top artists.\n\n        This function updates each 'Artist' object with a list of the artist's related \n        artists using the Spotify Web API. \n\n        Args:\n            key (spotipy.Spotify): Authenticated Spotify API client.\n            top_ten_artists (list of Artist): A list of 'Artist' objects to query.\n        \n        Raises: \n            spotipy.SpotifyException: If there is an error in the Spotify API request.\n        \"\"\"\n        sp = key \n        related_artists = sp.artist_related_artists(self.id)\n        self.related_artists = [musician['name'] for musician in related_artists['artists']]\n```\n:::\n\n\n## Define Functions\nFor this project, I need to make two distinct calls to the Spotify Web API. After the data is returned, it is processed and used to set the `Artist` class' attributes. Both the method associated with the `Artist` class and function defined below utilize a function from the <a href=\"https://spotipy.readthedocs.io/en/2.24.0/\">Spotipy</a> library to make API calls and then parse the data.\n\n::: {#27388bb3 .cell execution_count=2}\n``` {.python .cell-code}\n# data_functions.py\nimport spotipy\nfrom data_classes import Artist\n\ndef collect_top_artists(key, time_period, n_artists):\n    \"\"\"\n    Collects the user's top Spotify artists.\n\n    Retrieves the user's top artists over a given time period from the Spotify Web API. \n    It returns a list of 'Artist' instances.\n\n    Args:\n        key (spotipy.Spotify): Authenticated Spotify API client.\n        time_period (str): The time range over which to retrieve top artists. \n                           Valid values are 'short_term' (1 month), 'medium_term' \n                           (6 months), and 'long_term' (all-time).\n        n_artists (int): The number of top artists to retrieve.\n                           \n    Returns:\n        A list of 'Artist' objects representing the user's top artists.\n        \n    Raises:\n        spotipy.SpotifyException: If there is an error in the Spotify API request.\n    \"\"\"\n    sp = key \n    top_artists = sp.current_user_top_artists(time_range=time_period, limit=n_artists)\n    top_thirty_artists = []\n    for i in range(n_artists):\n        top_thirty_artists.append(Artist(top_artists['items'][i]['name'], \n                                      top_artists['items'][i]['id'], \n                                      top_artists['items'][i]['images'][0]['url'], \n                                      top_artists['items'][i]['popularity'], i + 1))\n    return top_thirty_artists\n```\n:::\n\n\n## Import Libraries, Modules, and Environment Variables\nBefore I can collect data and visualize my network of Spotify artists, I need to obtain a Spotify authentication token. This can be done with a number of parameters available through the \n<a href=\"https://developer.spotify.com/documentation/web-api/tutorials/getting-started\">Spotify Developer portal</a>. \n\nI also define two variables -- `N_ARTISTS` and `TIME_PERIOD` -- in the following code chunk. Knowing my tendency to listen to a few artists in a high concentration, I opted to query only my top 30 artists. Querying more artists may lead to a more interesting graph but poses the risk of diluting the focus of the analysis. Including artists I hardly listen to in my analysis will provide little insight into my music taste. As for the time period I'll be querying, I opted to go with my data from the last six months (medium term). \n\n::: {#488c10cf .cell execution_count=3}\n``` {.python .cell-code}\n# main.py\nimport spotipy \nfrom spotipy.oauth2 import SpotifyOAuth\nfrom data_classes import Artist\nfrom data_functions import collect_top_artists, collect_related_artists\nimport dotenv\nimport os \nimport networkx as nx\nimport matplotlib.pyplot as plt\nfrom pyvis.network import Network\n\n# Load environment variables\ndotenv.load_dotenv()\n \nCLIENT_ID = os.getenv(\"SPOTIFY_CLIENT_ID\")\nCLIENT_SECRET = os.getenv(\"SPOTIFY_CLIENT_SECRET\")\nREDIRECT_URI = os.getenv(\"SPOTIFY_REDIRECT_URI\")\nSCOPE = os.getenv(\"SPOTIFY_SCOPE\")\n\n# Authenticate your Spotify account -- this will be your key\nsp = spotipy.Spotify(auth_manager=SpotifyOAuth(client_id=CLIENT_ID, \n                                               client_secret=CLIENT_SECRET,\n                                               redirect_uri=REDIRECT_URI,\n                                               scope=SCOPE))\n\n# Define how many artists to query and over which length of time \nN_ARTISTS = 30\nTIME_PERIOD = \"medium_term\"\n```\n:::\n\n\n## Code Execution\nI am creating my network with <a href=\"https://networkx.org/documentation/stable/index.html\">NetworkX</a> and visualizing it with <a href=\"https://pyviz.org/\">PyViz</a>. To enhance the network visualization, I'm using each artist's Spotify image to depict their node. \n\nOne thing worth noting is that Spotify's \"Fans Also Like\" is not always recriprocal. For example, Kacey Musgraves appears on Noah Kahan's \"Fans Also Like\" but he does not appear on hers. A directed graph would most commonly be used to represent this type of relationship. However, I am using an undirected graph because the presence of an artist under another artist's \"Fans Also Like\" -- even if it is not recripocated -- is reflective of a shared subset of fans. Artists who share a reciprocal connection will be connected by a bolder line, which represents an edge with greater weight.\n\n::: {#6594940e .cell execution_count=4}\n``` {.python .cell-code}\n# main.py\n# Store artist data in a list (note that data is stored in Artist class)\ntop_thirty_artists = collect_top_artists(sp, TIME_PERIOD, N_ARTISTS)\n\n# Collect list of artists in each artist's \"Fans also like\"\nfor artist in top_thirty_artists:\n    artist.collect_related_artists(sp)\n\n# Initialize your network of artists\nN = nx.Graph()\n\n# Create a node for each of the top artists\nfor artist in top_thirty_artists:\n    N.add_node(artist.name, size=30, shape='circularImage', image=artist.image_url)\n\n# Check if each top artist is in the other top artists' \"Fans also like\" \n# If edge already exists, adjust the weight; create edge if one does not exist \nfor artist in top_thirty_artists:\n    for different_artist in top_thirty_artists:\n        if artist != different_artist:\n            if artist.name in different_artist.related_artists:\n                if N.has_edge(artist.name, different_artist.name):\n                    N[artist.name][different_artist.name]['weight'] += 1\n                else:\n                    N.add_edge(artist.name, different_artist.name, weight=1, color=\"black\")\n\n# Store the betweenness centrality of each artist in a dictionary\ncentrality_values = nx.betweenness_centrality(N)\n\n# Store the degree centrality of each artist in a dictionary\ndegree_values = nx.degree_centrality(N)\n\nnet_test = Network(notebook=True, directed=False, height='95vh', width='100%')\nnet_test.from_nx(N)\nnew_test_path = 'graph.html'\nnet_test.show(new_test_path)\n```\n:::\n\n\n\n\n## Results\n_Zoom within the frame for a better view of the artists. Click and drag nodes to move artists._\n<iframe src=\"graph30.html\" width=\"100%\" height=\"600px\" frameborder=\"0\"></iframe>\n\n:::{.callout-note}\nI am using _cluster_ in accordance with John Scott's definition: \"An area of relatively high density in a graph\" (2000, p. 127).\n:::\n\nAt first glance, the graph reveals two distinct clusters. In addition to those two clusters, there are five artists without any connections; they are completely isolated from the rest of the network. \n\nOne metric we can use to describe the graph is inclusiveness, \"...the number of points that are included within the various connected parts of the graph\" (Scott, 2000, p. 70). __Considering five of my top 30 artists are without any connections, the inclusiveness of my network (expressed as a proportion) is 0.83.__ A perfectly inclusive network would have an inclusiveness score of 1. Without other Spotify networks to compare to, it is impossible for me to say if my network of top artists is highly or minimally inclusive.  \n\nTo better understand which artists are most important in my network, I turned to centrality measures. The two centrality measures I'm interested in for this project are betweenness centrality and degree centrality. \n\nBetweenness centrality measures \"...the extent to which a particular point lies 'between' the various other points in the graph\" (Scott, 2000, 87). One can think of betweenness centrality as a measure of how important a node is as a \"bridge\" between other nodes. __The artists with the two highest betweenness centrality scores in my network are The Weeknd and Noah Kahan.__ The Weeknd's role as a bridge is especially apparent as he is the sole connector between my \"pop\" artists and \"hip hop/R&B\" artists.\n\nDegree centrality is effectively a popularity score as it measures how many nodes a node is connected to. __The Weeknd, Gregory Alan Isakov, and Billie Eilish tied for the highest degree centrality with a 0.28.__ \n\n__Network analysis reveals that my music taste is not one-dimensional and is most strongly characterized by two distinct clusters of artists. The Weeknd's role as both a connector and highly popular figure in my network of artists underscores his significance in my music preferences.__\n\n## Future Applications\nWhile this project utilized network analysis for its descriptive power, network analysis can also be used for predictive purposes. One such use case would be a recommendation system to recommend new artists whose music a person is likely to enjoy. Beyond music preferences and listening habits, network analysis offers valuable applications in a number of business contexts. For example, network analysis may be immensely valuable in a merger and acquisition, where seamless integration is of the utmost importance. Network analysis could reveal structural holes and knowledge gaps that would have the potential to lead to a loss of tribal knowledge and disrupt integration processes. \n\n## References\n_Fans also like_. Spotify. (n.d.). https://support.spotify.com/us/artists/article/fans-also-like/ \n<br>\n<br>\nHevey, D. (2018). Network analysis: a brief overview and tutorial. Health Psychology and Behavioral Medicine, 6(1), 301â€“328. https://doi.org/10.1080/21642850.2018.1521283\n<br>\n<br>\nScott, J. (2000). Social Network Analysis: A Handbook (Second Edition). Sage Publications. \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}